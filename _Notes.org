Commit Notes
------------

TODO
----
  if !is_symmetric(bf)
    for i=1:num_int_bels, j=1:num_int_bels
      if mod(nnz, 500) == 0 println(STDERR, "ii($i,$j)") end
      const vbf_ij = int_bel_vs_int_bel(beln(i), beln(j), basis, bf)
      if vbf_ij != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ij
        row_nums[nnz] = j
        col_nums[nnz] = i
      end
    end
    for i=first_nb_side_bel:basis.total_bels, j=1:num_int_bels
      if mod(nnz, 500) == 0 println(STDERR, "si($i,$j)") end
      const bel_i = beln(i)
      const bel_j = beln(j)
      const vbf_ij = side_bel_vs_int_bel(bel_i, bel_j, basis, bf)
      if vbf_ij != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ij
        row_nums[nnz] = j
        col_nums[nnz] = i
      end
      const vbf_ji = int_bel_vs_side_bel(bel_j, bel_i, basis, bf)
      if vbf_ji != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ji
        row_nums[nnz] = i
        col_nums[nnz] = j
      end
    end
    for i=first_nb_side_bel:basis.total_bels, j=first_nb_side_bel:basis.total_bels
      if mod(nnz, 500) == 0 println(STDERR, "ss($i,$j)") end
      const vbf_ij = side_bel_vs_side_bel(beln(i), beln(j), basis, bf)
      if vbf_ij != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ij
        row_nums[nnz] = j
        col_nums[nnz] = i
      end
    end
  else # bf is symmetric
    for i=1:num_int_bels
      const bel_i = beln(i)
      for j=1:i-1
        if mod(nnz, 500) == 0 println(STDERR, "ii($i,$j)") end
        const vbf_ij = int_bel_vs_int_bel(bel_i, beln(j), basis, bf)
        if vbf_ij != zeroR
          nnz += 1
          nonzeros[nnz] = vbf_ij
          row_nums[nnz] = j
          col_nums[nnz] = i
          nnz += 1
          nonzeros[nnz] = vbf_ij
          row_nums[nnz] = i
          col_nums[nnz] = j
        end
      end
      const vbf_ii = int_bel_vs_int_bel(bel_i, bel_i, basis, bf)
      if vbf_ii != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ii
        row_nums[nnz] = i
        col_nums[nnz] = i
      end
    end
    for i=first_nb_side_bel:basis.total_bels, j=1:num_int_bels
      if mod(nnz, 500) == 0 println(STDERR, "si($i,$j)") end
      const vbf_ij = side_bel_vs_int_bel(beln(i), beln(j), basis, bf)
      if vbf_ij != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ij
        row_nums[nnz] = j
        col_nums[nnz] = i
        nnz += 1
        nonzeros[nnz] = vbf_ij
        row_nums[nnz] = i
        col_nums[nnz] = j
      end
    end
    for i=first_nb_side_bel:basis.total_bels
      const bel_i = beln(i)
      for j=first_nb_side_bel:i-1
        if mod(nnz, 500) == 0 println(STDERR, "ss($i,$j)") end
        const vbf_ij = side_bel_vs_side_bel(bel_i, beln(j), basis, bf)
        if vbf_ij != zeroR
          nnz += 1
          nonzeros[nnz] = vbf_ij
          row_nums[nnz] = j
          col_nums[nnz] = i
          nnz += 1
          nonzeros[nnz] = vbf_ij
          row_nums[nnz] = i
          col_nums[nnz] = j
        end
      end
      const vbf_ii = side_bel_vs_side_bel(bel_i, bel_i, basis, bf)
      if vbf_ii != zeroR
        nnz += 1
        nonzeros[nnz] = vbf_ii
        row_nums[nnz] = i
        col_nums[nnz] = i
      end
    end
  end

end



















In the mesh, make sure nb_side_num_for_fe_side is as fast as possible, store precomputed values if necessary.


In VBF bel vs bel function:
  First precompute all bel vs bel vbf values for each oshape in the mesh
    oshape, face, mon #, face, mon # -> vbf value
    Then for each fe,
      for each pair of non-boundary sides sf1, sf2,
      compute (with help of the basis) the bel numbers for the first monomials on the sides
      for each monomial pair between the sides,
      lookup the vbf value for the pair, store in the matrix, assuming sequential numbering after the first monomials.



5x5x5x5 mesh, interior polys deg 3, sides deg 2
625 finite elements
35 basis monomials per interior
10 basis monomials per side
2000 nb sides
41875 basis elements
1753515625 basis element pairs


Try using a sparse matrix solver in WG.solve, currently can't find/import the SuiteSparse module/package.
  https://groups.google.com/forum/?hl=en&fromgroups=#!topic/julia-users/3tTljDSQ6cs
  "In julia, you are using \ to solve the system. This currently defaults to using LU factorization.
   However, if your system is SPD, there are gains from using a cholesky solver. Matlab does this
   automatically, and Julia does this automatically in the dense case, but not yet in the sparse case."


Lookup choice of polynomials necessary for classic WG on rectangles.
  Need to be able to paramterize basis and WGrad by
     degree limits for basis polynomials, as pair of limit and type enum
     weak gradient space

Implement triple bar norm (vbf) error.

Concatenate two rectangular meshes left/right or upper/lower?
  Only fes on the joined boundary will need to have new computations.
 _____ ____
|     |____|
|     |____|
|_____|____|


Documentation Changes
---------------------
rmesh docs:
  New interface functions:
    integral_prod_on_ref_fe_side_vs_outward_normal
    integral_vs_local_monomial_on_fe_interior
    integral_on_ref_fe_face
    num_side_faces_per_fe
    space_dim
    is_boundary_side
    side_face
    dependent_axis_for_side_face
    fe_diameter
    one_mon
  Change description of basis ordering, now pure lexicographically ordered.
  Change description of side basis size, and describe interaction with mesh to find "dependent dimension" for a side to form the basis there.
